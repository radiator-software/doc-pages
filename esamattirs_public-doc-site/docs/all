{"items":[{"contextPath":[["aaa","policy","handler"]],"id":"conditions","type":"block","title":"Handler conditions configuration","shortDescription":"Configures conditions for handler matching","content":"# conditions\n\nEach handler can be configured with an optional conditions clause. This clause is used to constraint which requests will be handled with it. If conditions are not defined, the handler will handle any request. A condition rule consists of a namespace attribute, comparison operator and one or more values to compare.\n\nPolicy and handler conditions are defined as:\n\n```\nconditions <all | any | none> {\n    <namespace attribute> <comparison operator> <value>;\n    <namespace attribute> <comparison operator> [<value> <value> <value>];\n    ...\n}\n```\n\nSupported matching strategies are:\n\n- `all`: All condition rules must match\n- `any`: Any condition rule must match\n- `none`: None of conditions rules must match\n\nThe syntax for configuring conditions for handlers is identical to configuring conditions for policies.\n\nExample configuration of a handler conditions clause:\n\n```\nconditions all {\n    aaa.accounting == false;\n}\n```","insertText":"conditions ${1|all,any,none|} {\n\t$0\n}"},{"contextPath":[[]],"id":"aaa","type":"block","title":"AAA clause","shortDescription":"Configures AAA policies","content":"# aaa\n\nTODO","insertText":"aaa {\n\t$0\n}"},{"contextPath":[["aaa","policy"]],"id":"conditions","type":"block","title":"Policy conditions configuration","shortDescription":"Configures conditions for policy matching","content":"# conditions\n\nEach policy can be configured with an optional conditions clause. This clause is used to constrain which requests will be handled with it. If conditions are not defined, the policy will handle any request. A condition rule consists of a namespace attribute, comparison operator and one or more values to compare.\n\nPolicy and handler conditions are defined as:\n\n```\nconditions <all | any | none> {\n    <namespace attribute> <comparison operator> <value>;\n    <namespace attribute> <comparison operator> [<value> <value> <value>];\n    ...\n}\n```\n\nSupported matching strategies are:\n\n- `all`: All condition rules must match\n- `any`: Any condition rule must match\n- `none`: None of conditions rules must match\n  The format for configuring conditions for handlers is identical to configuring conditions for policies.","insertText":"conditions ${1|all,any,none|} {\n\t$0\n}"},{"contextPath":[["aaa","policy","handler"]],"id":"accounting","type":"block","title":"accounting clause","shortDescription":"Configures accounting processing.","content":"# accounting\n\n\nVariant of [`execute`](./aaa.policy.handler.execute.md) which is only executed\nfor accounting requests.\n\n```\naaa {\n    policy \"DEFAULT\" {\n        handler \"ACCOUNNTIG\" {\n            accounting {\n                # acknowledge all accounting even if this\n                # handler should not receive any\n                accept;\n            }\n        }\n    }\n}\n```","insertText":"accounting {\n\t$0\n}"},{"contextPath":[["aaa","policy","handler"]],"id":"authentication","type":"block","title":"Authentication clause","shortDescription":"Configures authentication processing.","content":"# authentication\n\nVariant of [`execute`](./aaa.policy.handler.execute.md) which is only executed\nfor authentication requests.","insertText":"authentication {\n\t$0\n}"},{"contextPath":[["aaa","policy","handler"]],"id":"authorization","type":"block","title":"Authentication clause","shortDescription":"Configures authentication processing.","content":"# authorization\n\nVariant of [`execute`](./aaa.policy.handler.execute.md) which is only executed\nfor authentication requests.\n\nOn RADIUS and HTTP servers this is executed after successul authentication\npipeline on non-accounting requests","insertText":"authentication {\n\t$0\n}"},{"contextPath":[["aaa","policy"]],"id":"handler","type":"block","title":"Policy handler configuration","shortDescription":"Configures single handler for an AAA policy.","content":"# handler\n\nThis is the start of a handler clause. The handler specifies how incoming requests are processed. The handler can, for example, be used to specify authentication methods, authorization rules, post-AA actions and logging. Multiple handlers can be defined within a policy.\n\nA handler configuration consists of one or more blocks returning a value which is either none, accept, or reject.\n\nBy default, directives and statement clauses within a clause are executed in order until a reject is returned or the return value of the last directive or statement clause is returned. Changing this can be done by specifying an inner statement clause with a different strategy.\n\nExample configuration of a handler clause inside a default policy:\n\n```\npolicy \"default\" {\n\n    # Policy handler named \"default\"\n    handler \"default\" {\n        # Try to authenticate requests\n        authentication {\n            # Search for username from backend \"users\"\n            backend \"users\";\n\n            # Try to authenticate user with PAP\n            pap;\n        }\n\n        # Authorize authenticated requests\n        authorization {\n            # Set a reply message based on user's role\n            map user.role {\n                \"admin\" => {\n                    message \"Welcome admin!\";\n                }\n                \"guest\" => {\n                    message \"Welcome guest!\";\n                }\n            }\n\n            # Explicitly accept, if user's roles didn't match\n            accept;\n        }\n\n        # Log authentication requests\n        post-authentication {\n            # Log with AAA logger \"auth\"\n            log \"auth\" {\n                format \"%{datetime.timestamp} method=%{aaa.method} username=\\\"%{aaa.identity}\\\" result=%{aaa.result} reason=\\\"%{aaa.reason}\\\"\";\n            }\n        }\n\n        # Explicitly just accept any accounting requests\n        accounting {\n            accept;\n        }\n    }\n}\n```","insertText":"handler \"${1:HANDLER_NAME}\" {\n\t$0\n}"},{"contextPath":[["aaa","policy","handler"]],"id":"post-accounting","type":"block","title":"Post-accounting clause","shortDescription":"Configures post-accounting.","content":"# post-accounting\n\nVariant of [`post-execute`](./aaa.policy.handler.post-execute.md) for\n[`accounting`](./aaa.policy.handler.accounting.md) which is only executed for\naccounting requests.","insertText":"post-accounting {\n\t$0\n}"},{"contextPath":[["aaa","policy","handler"]],"id":"post-authentication","type":"block","title":"Pre-authentication clause","shortDescription":"Configures post-authentication.","content":"# post-authentication\n\nVariant of [`post-execute`](./aaa.policy.handler.post-execute.md) for\n[`authentication`](./aaa.policy.handler.authentication.md) which is only\nexecuted for authentication requests.","insertText":"post-authentication {\n\t$0\n}"},{"contextPath":[["aaa","policy","handler"]],"id":"post-authentication","type":"block","title":"Pre-authentication clause","shortDescription":"Configures post-authentication.","content":"# post-authorization\n\nVariant of [`post-execute`](./aaa.policy.handler.post-execute.md) for\n[`authorization`](./aaa.policy.handler.authorization.md) which is only\nexecuted for authorization requests.","insertText":"post-authentication {\n\t$0\n}"},{"contextPath":[["aaa","policy","handler"]],"id":"pre-accounting","type":"block","title":"Pre-accounting clause","shortDescription":"Configures pre-accounting.","content":"# pre-accounting\n\nVariant of [`pre-execute`](./aaa.policy.handler.pre-execute.md) for\n[`accounting`](./aaa.policy.handler.accounting.md) which is only executed for\naccounting requests.","insertText":"pre-accounting {\n\t$0\n}"},{"contextPath":[["aaa","policy","handler"]],"id":"pre-authentication","type":"block","title":"Pre-authentication clause","shortDescription":"Configures pre-authentication.","content":"# pre-authentication\n\nVariant of [`pre-execute`](./aaa.policy.handler.pre-execute.md) for\n[`authentication`](./aaa.policy.handler.authentication.md) which is only\nexecuted for authentication requests.","insertText":"pre-authentication {\n\t$0\n}"},{"contextPath":[["aaa"]],"id":"policy","type":"block","title":"Policy configuration","shortDescription":"Configures an AAA policy with handlers","content":"# Policy\n\nThis is the start of a policy clause. The clause has a name which is defined as a string. A single policy can contain multiple handlers from which a first handler to match will be selected to handle the received request.\n\nExample configuration of a policy clause:\n\n```\npolicy \"Local network access\" {\n    handler \"WLAN Controllers\" {\n        # (Optional) Only requests matching the conditions will be handled by this handler\n        conditions all {\n            radius.client == \"WLAN Controllers\";\n        }\n\n        # Handler configuration\n        # ...\n    }\n\n    handler \"Network switches\" {\n        # (Optional) Only requests matching the conditions will be handled by this handler\n        conditions all {\n            radius.client == \"Network switches\";\n        }\n\n        # Handler configuration\n        # ...\n    }\n\n    # A handler without conditions will handle any request\n    handler \"Default handler\" {\n        # Handler configuration\n        # ...\n    }\n}\n```\n\nPolicies are configured within an aaa clause which can include multiple policies:\n\n```\naaa {\n    policy \"example1\" {\n\n    }\n\n    policy \"example2\" {\n\n    }\n}\n```","insertText":"policy \"${1:POLICY_NAME}\" {\n\thandler \"${2:HANDLER_NAME}\" {\n\t\t$0\n\t}\n}"},{"contextPath":[["backends"]],"id":"file","type":"block","title":"File-based backend configuration","shortDescription":"File-based backend for storing user credentials and attributes in text files.","content":"# file\n\nThe file backend allows Radiator to authenticate users against a simple text file. This is useful for basic authentication scenarios and testing purposes. The file contains a list of usernames and passwords, which are used to verify the user's credentials.\n\nExample configuration of a file backend:\n\n```\n# file backend configuration\nfile \"USERS_INTERNAL_FILE\" {\n    filename \"/var/lib/radiator/db/users-internal/users-internal.file\";\n}\n```\n\nThe filename attribute should be the name of the file backend.","insertText":"file \"${1:BACKEND_NAME}\" {\n\tfilename \"${2:PATH}\";\n\t$0\n}"},{"contextPath":[["backends","http"]],"id":"authentication","type":"block","title":"HTTP authentication configuration","shortDescription":"Configures authentication details for authenticating to the HTTP service.","content":"# authentication\n\nThis optional clause defines how Radiator authenticates to the HTTP service. Supported authentication methods include:\n\nBasic authentication:\n\n```\nauthentication {\n    # Both username and password parameter support\n    username \"<username>\";\n    password \"<password>\";\n}\n```\n\nBearer token authentication:\n\n```\nauthentication {\n    token \"<api_token>\";\n}\n```\n\nApiKey authentication:\n\n```\nauthentication {\n    header \"X-API-KEY\";\n    key \"<api_key>\";\n}\n```\n\nOauth2 authentication:\n\n```\nauthentication oauth2 {\n    device-url \"https://login.microsoftonline.com/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX/oauth2/v2.0/devicecode\";\n    token-url \"https://login.microsoftonline.com/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX/oauth2/v2.0/token\";\n    client \"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\";\n    scope \"user.read groupmember.read.all openid profile\";\n}\n```","insertText":"authentication {\n\t$0\n}"},{"contextPath":[["backends","http"]],"id":"connections","type":"variable","title":"HTTP connections","shortDescription":"Defines max number of concurrent connections.","content":"# connections\n\nThis optional parameter defines the maximum number of concurrent connections Radiator will maintain to the HTTP service.","insertText":"connections ${1:10};"},{"contextPath":[["backends"]],"id":"http","type":"block","title":"HTTP backend configuration","shortDescription":"HTTP backend for authentication against REST APIs and web services.","content":"# http\n\nThe HTTP backend enables Radiator to make HTTP requests to external web services for authentication and authorization purposes.","insertText":"http \"${1:name}\" {\n\turl \"${2:https://api.example.com}\";\n}"},{"contextPath":[["backends","http"]],"id":"timeout","type":"variable","title":"HTTP timeout","shortDescription":"Defines how long Radiator will wait for a response from the HTTP service.","content":"# timeout\n\nThe timeout parameter in HTTP backend configuration specifies the maximum time that Radiator will wait for a response from the HTTP service before considering the request to have failed.\n\n## Duration Units\n\nThis parameter supports [duration units](/docs/articles/duration-units.md) for improved readability:\n\n```radiator-config\nbackends {\n    http \"api\" {\n        url \"https://api.example.com\";\n        timeout 30s;  # 30 seconds\n    }\n}\n```","insertText":"timeout ${1:30s};"},{"contextPath":[["backends","http"]],"id":"tls","type":"block","title":"HTTP tls configuration","shortDescription":"Defines TLS settings when connecting to HTTPS services.","content":"# tls\n\nThis optional clause configures Transport Layer Security (TLS) settings when connecting to HTTPS services:\n\n```\ntls {\n    # HTTP client's certificate\n    certificate \"http.client.cert\";\n\n    # HTTP client's private key\n    certificate_key \"http.client.key\";\n\n    # HTTP client's certificate's root CA\n    client_ca_certificate \"http.client.ca\";\n\n    # (Optional) HTTP backend's certificate's root CA\n    #server_ca_certificate \"http.backend.name.ca\";\n\n    # Custom certificate verification rules are not supported for HTTP backend\n}\n```","insertText":"tls {\n\t$0\n}"},{"contextPath":[["backends","http"]],"id":"url","type":"variable","title":"HTTP endpoint URL","shortDescription":"Base URL for HTTP API endpoints and requests.","content":"# url\n\nThis attribute specifies the base URL used to establish a connection with the HTTP service.","insertText":"url \"${1:https://api.example.com}\";"},{"contextPath":[["backends"]],"id":"jsonfile","type":"block","title":"JSON file based backend configuration","shortDescription":"JSON File based backend for storing user credentials and attributes in text files.","content":"# jsonfile\n\nThe JSON file backend allows Radiator to authenticate users against a JSON formatted text file. The JSON file can be queried using\nthe `jsonpath` [filter](/docs/articles/filters.md) to extract user credentials and attributes.\n\nHere's an example configuration of a JSON file backend with comments explaining each statement:\n\n```radconf\njsonfile \"JSON_FILE\" {\n    # Path to the JSON file containing user data.\n    filename \"users.json\";\n\n    # Enable file monitoring for changes. Defaults to true.\n    monitor true;\n\n    # Alternatively it is possible to define the JSON content directly in the configuration.\n    # Not allowed if filename is used.\n    content \"\"\"\n        {\n            \"users\": {\n                // Comments are allowed in JSON\n                \"alice\": {\n                    \"username\": \"alice\",\n                    \"password\": \"{argon2}$argon2id$v=19$m=19456,t=2,p=1$56MJ6kkHsbicXkvq6+r5dA$zY5kHLjEfJET8VT7hFV+uHcxgTE8w66Z4dYwwbZtdxw\",\n                    \"groups\": [\"admin\", \"user\"]\n                },\n            }, // dangling comma is allowed\n        }\n    \"\"\";\n\n\n    # At least one query block must be defined\n    query \"FIND_USER\" {\n        # Mapping provides access to a single variable, `doc` which is the parsed JSON document.\n        mapping {\n            user.username = doc | jsonpath(\"$.users['%{aaa.identity}'].username\");\n            user.password = doc | jsonpath(\"$.users['%{aaa.identity}'].password\");\n            user.group = doc | jsonpath(\"$.users['%{aaa.identity}'].groups[*]\");\n\n            # It is also possible to extract the user data object and filter it further in the policy.\n            vars.full_userdata = doc | jsonpath(\"$.users['%{aaa.identity}']\");\n        }\n    }\n\n}\n```\n\n## Notes\n\n - If the monitor is `true` and the file changes to invalid JSON, the backend will keep serving the last valid content.\n - File changes to non-relevant parts, e.g. whitespace or comments, do not trigger a reload.\n - The JSON file can contain comments and dangling commas.","insertText":"jsonfile \"${1:BACKEND_NAME}\" {\n\tfilename \"${2:PATH}\";\n\t$0\n}"},{"contextPath":[["backends","ldap","server"]],"id":"authentication","type":"block","title":"LDAP authentication configuration","shortDescription":"Configures authentication credentials for binding to the LDAP server.","content":"# authentication\n\nThe optional authentication clause is used to specify how Radiator authenticates to the LDAP server.\n\nExample configuration of an authentication clause:\n\n```\nauthentication {\n    # Basic bind authentication\n    dn \"cn=read-only-admin,dc=example,dc=com\";\n    password \"password\";\n\n    # SASL External authentication (for example TLS client certificate)\n    #external;\n\n    # SASL GSS-API authentication;\n    #gss-api;\n}\n```","insertText":"authentication {\n\t$0\n};"},{"contextPath":[["backends","ldap","server"]],"id":"connections","type":"variable","title":"LDAP connections configuration","shortDescription":"Defines how many sockets/connections at maximum to open.","content":"# connections\n\nThis attribute specifies the maximum number of sockets/connections that Radiator will open to the LDAP server. This limits the number of concurrent LDAP requests that can be handled, helping to prevent resource exhaustion.","insertText":"connections ${1:10};"},{"contextPath":[["backends"]],"id":"ldap","type":"block","title":"LDAP backend configuration","shortDescription":"LDAP (Lightweight Directory Access Protocol) backend for authentication against directory servers like Active Directory.","content":"# ldap\n\nThe ldap backend allows Radiator to authenticate and authorize users against an LDAP directory.\n\nExample configuration of an LDAP backend:\n\n```\nldap \"ldap.forumsys.com\" {\n    # LDAP server\n    server \"ldap.forumsys.com\" {\n        # LDAP URL\n        url \"ldap://ldap.forumsys.com:389/\";\n\n        # Operation timeout (supports duration units like 3s, 5m, 1h)\n        timeout 3s;\n\n        # How many sockets/connections at maximum to open\n        #connections 10;\n\n        # (Optional) Authentication\n        authentication {...}\n\n        # (Optional) TLS client configuration\n        #tls {...}\n    }\n\n    # A single backend can have multiple LDAP servers configured\n    #server \"ldap2\" {\n    #   ...\n    #}\n\n    # (Optional) Per search/operation authentication\n    #authentication {\n    #    # Basic bind authentication\n    #    # Both dn and password parameter support %{...} attribute templates\n    #    dn \"uid=%{aaa.identity},dc=example,dc=com\";\n    #    password \"%{auth.response}\";\n    #}\n\n    # LDAP operations\n\n    # LDAP search operation named \"user_groups\"\n    search \"user_groups\" {\n        base \"dc=example,dc=com\";\n        scope sub;\n        filter \"(&(objectClass=groupOfUniqueNames)(uniqueMember=uid=%{aaa.identity},dc=example,dc=com))\";\n\n        # Result values mapping\n        mapping {\n            user.group += ou;\n        }\n    }\n}\n```","insertText":"ldap \"${1:BACKEND_NAME}\" {\n\tserver \"${2:SERVER_NAME}\" {\n\t\turl \"${3:ldap://localhost:389}\";\n\t\t$0\n\t}\n}"},{"contextPath":[["backends","ldap"]],"id":"search","type":"block","title":"LDAP search operation","shortDescription":"Defines a named LDAP search operation with base, scope, and filter.","content":"# search\n\nDefines an LDAP search operation. This operation is used to query the LDAP directory for user information based on specified criteria.\n\nExample configuration of a search clause:\n\n```\nsearch \"find_user\" {\n    base \"uid=%{aaa.identity},dc=example,dc=com\";\n    scope base;\n    filter \"objectClass=inetOrgPerson\";\n\n    # Result value mapping\n    mapping {\n        user.username = uid;\n        user.password = mail;\n    }\n}\n```","insertText":"search \"${1:OPERATION_NAME}\" {\n\t$0\n}"},{"contextPath":[["backends","ldap"]],"id":"server","type":"block","title":"LDAP server configuration","shortDescription":"Defines an LDAP server with connection and authentication settings.","content":"# server\n\nThis clause defines the LDAP server to connect to. A single backend can have multiple LDAP servers configured. The server is configured with a name.\n\nExample configuration of an LDAP server:\n\n```\nserver \"ldap.forumsys.com\" {\n    # LDAP URL\n    url \"ldap://ldap.forumsys.com:389/\";\n\n    # Operation timeout (supports duration units like 3s, 5m, 1h)\n    timeout 3s;\n\n    # How many sockets/connections at maximum to open\n    #connections 10;\n\n    # (Optional) Authentication\n    authentication {...}\n\n    # (Optional) TLS client configuration\n    #tls {...}\n}\n```","insertText":"server \"${1:SERVER_NAME}\" {\n\t$0\n}"},{"contextPath":[["backends","ldap","server"]],"id":"timeout","type":"variable","title":"LDAP operation timeout","shortDescription":"Defines how long Radiator will wait for an LDAP operation to complete.","content":"# timeout\n\nThis attribute specifies the maximum amount of time that Radiator will wait for an LDAP operation to complete.\n\n## Duration Units\n\nThis parameter supports [duration units](/docs/articles/duration-units.md) for improved readability:\n\n```radiator-config\nbackends {\n    ldap \"directory\" {\n        server \"ldap.example.com\" {\n            url \"ldap://ldap.example.com:389/\";\n            timeout 5s;  # 5 seconds\n        }\n    }\n}\n```","insertText":"timeout ${1:5s};"},{"contextPath":[["backends","ldap"]],"id":"tls","type":"block","title":"LDAP TLS configuration","shortDescription":"Configures TLS settings for the LDAP connection.","content":"# tls\n\nThis optional clause configures TLS (Transport Layer Security) settings for the LDAP connection.\n\nExample configuration of a LDAP backend TLS clause:\n\n```\ntls {\n    # LDAP client's certificate\n    certificate \"ldap.client.cert\";\n\n    # LDAP client's private key\n    certificate_key \"ldap.client.key\";\n\n    # LDAP client's certificate's root CA\n    client_ca_certificate \"ldap.client.ca\";\n\n    # LDAP server's certificate's root CA\n    server_ca_certificate \"ldap.server.ca\";\n\n    # Custom certificate verification rules are not supported for LDAP server\n}\n```","insertText":"tls {\n\t$0\n}"},{"contextPath":[["backends","ldap","server"]],"id":"url","type":"variable","title":"LDAP server URL","shortDescription":"LDAP URL for connecting to the directory server.","content":"# url\n\nThis is the URL of the LDAP server for connecting to the directory server.","insertText":"url \"${1:ldap://localhost:389}\";"},{"contextPath":[[]],"id":"backends","type":"block","title":"Backends configurations","shortDescription":"Defines backend data sources for user authentication, authorization data, and accounting storage.","content":"# backends\n\nThe backends clause tells where end user information is stored. Each backend should be configured with a string representing the backend's name. Backends are configured within a `backends` clause:\n\n```\nbackends {\n    # backends are configured here\n    file \"EXAMPLE_FILE_BACKEND\" {...}\n}\n```","insertText":"backends {\n\t$0\n}"},{"contextPath":[["backends","radius","server"]],"id":"connect","type":"block","title":"Connection configuration","shortDescription":"Configures the network connection parameters for the RADIUS server.","content":"# connect\n\nThis clause defines the connection parameters for the RADIUS backend server, specifying how Radiator establishes a connection to a server that is specified with specific parameters. These parameters include the transport protocol, either the IP address or the hostname, and the port number. This clause is not mandatory. It is used when RADIUS messages need to be forwarded to another RADIUS server. This is common in roaming scenarios, where authentication requests from local users are handled locally, while requests from roaming partners are forwarded to a remote RADIUS server.\n\nExample configuration of a connect clause:\n\n```\nconnect {\n    # transport protocol: udp/tcp/tls\n    protocol udp;\n\n    # server's IP address\n    ip 203.0.113.111;\n\n    # alternatively server's hostname\n    #hostname radius1.example.org;\n\n    # destination UDP port\n    port 1812;\n\n    # Optional: receive and send buffer size in bytes\n    #buffer 1048576;\n} # connect\n```","insertText":"connect {\n\t$0\n}"},{"contextPath":[["backends","radius","server"]],"id":"connections","type":"variable","title":"Server connections","shortDescription":"Number of concurrent connections to maintain with the RADIUS backend server.","content":"# connections\n\nThis optional parameter specifies the number of concurrent connections to maintain with the RADIUS backend server. This allows the backend server to handle multiple authentication requests simultaneously, improving performance and throughput.","insertText":"connections ${1:16};"},{"contextPath":[["backends","radius","server"]],"id":"idle_timeout","type":"variable","title":"Idle timeout","shortDescription":"Idle timeout in seconds for persistent connections (TCP/TLS).","content":"# idle_timeout\n\nWhen protocol is set to TCP or TLS, this optional parameter specifies the maximum amount of time that a connection to the RADIUS backend server can remain idle before it is closed. This helps to conserve resources and prevent connections from being held open indefinitely. If not specified, connections will remain open indefinitely, or until the server closes them.\n\n## Duration Units\n\nThis parameter supports [duration units](/docs/articles/duration-units.md) for improved readability:\n\n```radiator-config\nbackends {\n    radius \"upstream\" {\n        server \"radius1.example.org\" {\n            secret \"ExampleSecret\";\n            protocol tcp;\n            idle_timeout 5m;  # 5 minutes\n        }\n    }\n}\n```\n\nWhen no unit suffix is provided, the value is interpreted as seconds.","insertText":"idle_timeout ${1:5m};"},{"contextPath":[["backends"]],"id":"radius","type":"block","title":"RADIUS backend configuration","shortDescription":"RADIUS backend for proxying authentication requests to external RADIUS servers.","content":"# radius\n\nThis backend acts as a RADIUS proxy, forwarding authentication requests to other RADIUS servers.\n\nExample configuration of a RADIUS proxy backend:\n\n```\nradius \"RADIUS_PROXY_EXAMPLE_ORG\" {\n    # backend server selection\n    server-selection round-robin;\n\n    server \"radius1.example.org\" {\n        # RADIUS shared secret\n        secret \"ExampleSecret\";\n\n        # Request timeout (supports duration units like 7s, 5m, 1h)\n        timeout 7s;\n\n        # how many times to retry the request\n        retries 0;\n\n        # use status-server polling\n        # true = on, false = off\n        status false;\n\n        # how many sockets/connections at maximum to open\n        #connections 16;\n\n        connect {\n            # transport protocol: udp/tcp/tls\n            protocol udp;\n\n            # server's IP address\n            ip 203.0.113.111;\n\n            # alternatively server's hostname\n            #hostname radius1.example.org;\n\n            # destination UDP port\n            port 1812;\n\n            # Optional: receive and send buffer size in bytes\n            #buffer 1048576;\n        } # connect\n    } # server\n\n    server \"radius2.example.org\" {\n        secret \"ThisIsAnExampleSecret\";\n        timeout 7s;\n        retries 0;\n        status false;\n        connect {\n            protocol udp;\n            ip 203.0.113.112;\n            #hostname radius2.example.org;\n            port 1812;\n            buffer 1048576;\n        } # connect\n    } # server\n\n    # Modify/filter RADIUS request before proxying\n    pre-proxying {\n        # filter the following attributes before proxying\n        filter {\n            #cisco-avpair;\n            Tunnel-Type;\n            Tunnel-Medium-Type;\n            Tunnel-Private-Group-ID;\n        }\n        # modify the following attributes before proxying\n        modify {\n            radiusproxy.request.attr.Operator-Name := \"4EXAMPLE_COM:FI\";\n        }\n    } # pre-proxying\n\n    # Modify/filter RADIUS reply\n    post-proxying {\n        filter {\n            # filter all vendor specific attributes\n            #vendor-specific;\n            #cisco-avpair;\n            # filter attributes for VLAN assignment\n            Tunnel-Type;\n            Tunnel-Medium-Type;\n            Tunnel-Private-Group-ID;\n        } # filter\n    } # post-proxying\n} # radius \"RADIUS_PROXY_EXAMPLE_ORG\"\n```","insertText":"radius \"${1:BACKEND_NAME}\" {\n\tserver \"${2:SERVER_NAME}\" {\n\t\tsecret \"${3:SHARE_SECRET}\";\n\t\tconnect {\n\t\t\tprotocol ${4|udp,tcp,tls|};\n\t\t}\n\t}\n\t$0\n}"},{"contextPath":[["backends","radius","server"]],"id":"retries","type":"variable","title":"Number of retries","shortDescription":"Number of retry attempts for failed RADIUS requests.","content":"# retries\n\nThe `retries` parameter is designed to provide a degree of fault tolerance in case of temporary network issues or upstream server unavailability. If the proxy doesn't receive a response from the upstream server within a certain timeout period, it will retry the request.","insertText":"retries ${1:3};"},{"contextPath":[["backends","radius"]],"id":"server-selection","type":"statement","title":"Server selection strategy","shortDescription":"Strategy for selecting RADIUS servers when multiple servers are configured.","content":"# server-selection\n\nThis attribute determines how the server selects a backend server. Possible values are:\n\n- `round-robin`: Servers are selected in a round-robin fashion.\n- `fallback`: Servers are selected in order, with fallback to the next server if the current server is unavailable.\n- `no-fallback`: Only the first server is used. If it is unavailable, the request fails.\n\nExample configuration of server-selection:\n\n```\nradius \"EXAMPLE-SERVER\" {\n    server-selection round-robin;\n\n    # other server configuration options...\n}\n```","insertText":"server-selection ${1|fallback,round-robin,no-fallback|};"},{"contextPath":[["backends","radius"]],"id":"server","type":"block","title":"RADIUS server configuration","shortDescription":"Defines a RADIUS server","content":"# server\n\nThis is where the proxying server is defined. The server clause is configured with a name.","insertText":"server \"${1:SERVER_NAME}\" {\n\t$0\n}"},{"contextPath":[["backends","radius","server"]],"id":"status","type":"statement","title":"Server status","shortDescription":"Enable or disable the server for request processing.","content":"# status\n\nThis parameter enables or disables status-server polling for the next hop RADIUS backend server. When set to true, Radiator will periodically poll the next hop server to check its status. When set to false, status-server polling is disabled. This is useful for monitoring the availability and health of the next hop RADIUS backend server. The status parameter is defined as a boolean.","insertText":"status ${1|true,false|};"},{"contextPath":[["backends","radius","timeout"]],"id":"timeout","type":"variable","title":"Connection timeout","shortDescription":"Defines how long the RADIUS proxy will wait for a response from the upstream RADIUS server.","content":"# timeout\n\nThe timeout parameter specifies the amount of time that the RADIUS proxy will wait for a response from the upstream RADIUS server before considering the request to have timed out.\n\n## Duration Units\n\nThis parameter supports [duration units](/docs/articles/duration-units.md) for improved readability:\n\n```radiator-config\nbackends {\n    radius \"upstream\" {\n        server \"radius1.example.org\" {\n            secret \"ExampleSecret\";\n            timeout 7s;  # 7 seconds\n        }\n    }\n}\n```","insertText":"timeout ${1:7s};"},{"contextPath":[["backends"]],"id":"sqlite","type":"block","title":"SQLite database backend","shortDescription":"SQLite database backend for user authentication and data storage with embedded database capabilities.","content":"# sql\n\nThe SQL backend allows Radiator to authenticate and authorize users against various SQL databases, such as MySQL/MariaDB, PostgreSQL, and SQLite. The SQL backends are configured with a name.\n\nExample configuration of a SQLite backend:\n\n```\nsqlite \"SQL_DATABASE_USERS_INTERNAL\" {\n    # Database URL\n    # url \"sqlite:users-internal.sqlite\";\n\n    # Alternatively, configure a database filename\n    filename \"/var/lib/radiator/db/users-internal/users-internal.sqlite\";\n\n    # SQL query named \"FIND_USER\"\n    query \"FIND_USER\" {\n        # SQL statement\n        statement \"SELECT USERID, PASSWORD FROM USERIDS WHERE USERID = ?\";\n\n        # Query argument binding in order\n        bindings {\n            aaa.identity;\n        }\n\n        # Result value mapping\n        mapping {\n            user.username = USERID;\n            user.password = PASSWORD;\n        }\n    }\n\n    # SQL query named \"USER_GROUPS\"\n    query \"USER_GROUPS\" {\n        # SQL statement\n        statement \"SELECT groupname FROM groups INNER JOIN group_memberships ON groups.id = group_memberships.group_id INNER JOIN users ON group_memberships.user_id = users.id WHERE username = ?\";\n\n        # Query argument binding in order\n        bindings {\n            aaa.identity;\n        }\n\n        # Result values mapping\n        mapping {\n            user.group += groupname;\n        }\n    }\n}\n```","insertText":"sqlite \"${1:BACKEND_NAME}\" {\n\tfilename \"${2:/PATH/TO/DATABASE.sqlite}\";\n\t$0\n}"},{"contextPath":[["backends"]],"id":"postgres","type":"block","title":"PostgreSQL database backend","shortDescription":"PostgreSQL database backend for user authentication and data storage with advanced SQL features.","content":"# sql\n\nThe SQL backend allows Radiator to authenticate and authorize users against various SQL databases, such as MySQL/MariaDB, PostgreSQL, and SQLite. The SQL backends are configured with a name.\n\nExample configuration of a SQLite backend:\n\n```\nsqlite \"SQL_DATABASE_USERS_INTERNAL\" {\n    # Database URL\n    # url \"sqlite:users-internal.sqlite\";\n\n    # Alternatively, configure a database filename\n    filename \"/var/lib/radiator/db/users-internal/users-internal.sqlite\";\n\n    # SQL query named \"FIND_USER\"\n    query \"FIND_USER\" {\n        # SQL statement\n        statement \"SELECT USERID, PASSWORD FROM USERIDS WHERE USERID = ?\";\n\n        # Query argument binding in order\n        bindings {\n            aaa.identity;\n        }\n\n        # Result value mapping\n        mapping {\n            user.username = USERID;\n            user.password = PASSWORD;\n        }\n    }\n\n    # SQL query named \"USER_GROUPS\"\n    query \"USER_GROUPS\" {\n        # SQL statement\n        statement \"SELECT groupname FROM groups INNER JOIN group_memberships ON groups.id = group_memberships.group_id INNER JOIN users ON group_memberships.user_id = users.id WHERE username = ?\";\n\n        # Query argument binding in order\n        bindings {\n            aaa.identity;\n        }\n\n        # Result values mapping\n        mapping {\n            user.group += groupname;\n        }\n    }\n}\n```","insertText":"postgres \"${1:BACKEND_NAME}\" {\n\turl \"${2:postgresql://user:password@localhost:5432/db}\";\n\t$0\n}"},{"contextPath":[["backends"]],"id":"mysql","type":"block","title":"MySQL database backend","shortDescription":"MySQL/MariaDB database backend for user authentication and data storage with full SQL capabilities.","content":"# sql\n\nThe SQL backend allows Radiator to authenticate and authorize users against various SQL databases, such as MySQL/MariaDB, PostgreSQL, and SQLite. The SQL backends are configured with a name.\n\nExample configuration of a SQLite backend:\n\n```\nsqlite \"SQL_DATABASE_USERS_INTERNAL\" {\n    # Database URL\n    # url \"sqlite:users-internal.sqlite\";\n\n    # Alternatively, configure a database filename\n    filename \"/var/lib/radiator/db/users-internal/users-internal.sqlite\";\n\n    # SQL query named \"FIND_USER\"\n    query \"FIND_USER\" {\n        # SQL statement\n        statement \"SELECT USERID, PASSWORD FROM USERIDS WHERE USERID = ?\";\n\n        # Query argument binding in order\n        bindings {\n            aaa.identity;\n        }\n\n        # Result value mapping\n        mapping {\n            user.username = USERID;\n            user.password = PASSWORD;\n        }\n    }\n\n    # SQL query named \"USER_GROUPS\"\n    query \"USER_GROUPS\" {\n        # SQL statement\n        statement \"SELECT groupname FROM groups INNER JOIN group_memberships ON groups.id = group_memberships.group_id INNER JOIN users ON group_memberships.user_id = users.id WHERE username = ?\";\n\n        # Query argument binding in order\n        bindings {\n            aaa.identity;\n        }\n\n        # Result values mapping\n        mapping {\n            user.group += groupname;\n        }\n    }\n}\n```","insertText":"mysql \"${1:BACKEND_NAME}\" {\n\turl \"${2:mysql://user:password@localhost:3306/db}\";\n\t$0\n}"},{"contextPath":[["backends","mysql"],["backends","sqlite"],["backends","postgres"]],"id":"query","type":"block","title":"SQL query configuration","shortDescription":"Defines a named SQL query with bindings and result mapping.","content":"# query\n\nThis clause defines an SQL query operation that retrieves data from the database. The query clause is configured with a name.\n\nExample configuration of a query:\n\n```\n# SQL query named \"FIND_USER\"\nquery \"FIND_USER\" {\n    # SQL statement\n    statement \"SELECT USERID, PASSWORD FROM USERIDS WHERE USERID = ?\";\n\n    # Query argument binding in order\n    bindings {\n        aaa.identity;\n    }\n\n    # Result value mapping\n    mapping {\n        user.username = USERID;\n        user.password = PASSWORD;\n    }\n}\n```","insertText":"query \"${1:name}\" {\n\t$0\n}"},{"contextPath":[["backends","mysql"],["backends","sqlite"],["backends","postgres"]],"id":"url","type":"variable","title":"Database connection URL","shortDescription":"Complete connection URL for the database including credentials, host, port, and database name.","content":"# url\n\nThis attribute specifies the connection string used to establish a connection with the SQL database. The format of the URL depends on the specific SQL backend type being used.","insertText":"url \"${1:mysql://user:password@localhost:3306/db}\";"},{"contextPath":[["captures","capture"]],"id":"console","type":"statement","title":"Console capture","shortDescription":"Configures packet capture to console","content":"# console\n\nOutputs the captured RADIUS messages to the console.\n\nExample configuration of a console capture:\n\n```\ncaptures {\n    capture \"CAPTURE_TO_CONSOLE\" {\n        console;\n    }\n}\n```","insertText":"console;"},{"contextPath":[["captures","capture"]],"id":"file","type":"block","title":"File capture","shortDescription":"Configures packet capture to file.","content":"# file\n\nStores the captured RADIUS messages in a file. The file type is PcapNG.\n\nExample configuration of file captures:\n\n```\ncaptures {\n    capture \"CAPTURE_TO_DIRECTORY\" {\n        file {\n            directory \"/var/lib/radiator/captures\";\n        }\n    }\n\n    capture \"CAPTURE_TO_FILE\" {\n        file {\n            directory \"/var/lib/radiator/captures\";\n            filename \"radiator-server.pcap\";\n        }\n    }\n}\n```\n\nWhen using file capture destination, you can configure the output location using the following parameters:\n\n- `directory`: Specifies where capture files should be stored.\n- `filename`: Specifies the exact filename for the capture file. If not specified, a filename will be automatically generated. The automatically generated filename is named `context_id.pcapng` where `context_id` is the value of authentication context ID that can be logged, for example, in the authentication log.\n\nWhen troubleshooting authentication issues, you can correlate authentication log entries with their corresponding capture files using the Context-Id. This example takes the last entry from a JSON formatted authentication log and uses the jq command to extract the value of Context-Id key.\n\n```bash\n% sudo tail -1 radiator-server-authentication.log | jq -r '.[\"Context-Id\"]'\nabc123def456789a\n% sudo ls -l /var/lib/radiator/captures/abc123def456789a.pcapng\n-rw-r----- 1 radiator radiator 41256 Jun  5 09:23 /var/lib/radiator/captures/abc123def456789a.pcapng\n```","insertText":"file {\n\tdirectory \"${1:/var/lib/radiator/captures}\";\n\tfilename \"${2:radiator-server.pcap}\";\n}"},{"contextPath":[["captures","capture","file"]],"id":"directory","type":"variable","title":"File directory","shortDescription":"Specifies where capture files should be stored.","content":"# file\n\nStores the captured RADIUS messages in a file. The file type is PcapNG.\n\nExample configuration of file captures:\n\n```\ncaptures {\n    capture \"CAPTURE_TO_DIRECTORY\" {\n        file {\n            directory \"/var/lib/radiator/captures\";\n        }\n    }\n\n    capture \"CAPTURE_TO_FILE\" {\n        file {\n            directory \"/var/lib/radiator/captures\";\n            filename \"radiator-server.pcap\";\n        }\n    }\n}\n```\n\nWhen using file capture destination, you can configure the output location using the following parameters:\n\n- `directory`: Specifies where capture files should be stored.\n- `filename`: Specifies the exact filename for the capture file. If not specified, a filename will be automatically generated. The automatically generated filename is named `context_id.pcapng` where `context_id` is the value of authentication context ID that can be logged, for example, in the authentication log.\n\nWhen troubleshooting authentication issues, you can correlate authentication log entries with their corresponding capture files using the Context-Id. This example takes the last entry from a JSON formatted authentication log and uses the jq command to extract the value of Context-Id key.\n\n```bash\n% sudo tail -1 radiator-server-authentication.log | jq -r '.[\"Context-Id\"]'\nabc123def456789a\n% sudo ls -l /var/lib/radiator/captures/abc123def456789a.pcapng\n-rw-r----- 1 radiator radiator 41256 Jun  5 09:23 /var/lib/radiator/captures/abc123def456789a.pcapng\n```","insertText":"directory \"${1:/var/lib/radiator/captures}\";"},{"contextPath":[["captures","capture","file"]],"id":"filename","type":"variable","title":"File name","shortDescription":"Specifies the exact filename for the capture file.","content":"# file\n\nStores the captured RADIUS messages in a file. The file type is PcapNG.\n\nExample configuration of file captures:\n\n```\ncaptures {\n    capture \"CAPTURE_TO_DIRECTORY\" {\n        file {\n            directory \"/var/lib/radiator/captures\";\n        }\n    }\n\n    capture \"CAPTURE_TO_FILE\" {\n        file {\n            directory \"/var/lib/radiator/captures\";\n            filename \"radiator-server.pcap\";\n        }\n    }\n}\n```\n\nWhen using file capture destination, you can configure the output location using the following parameters:\n\n- `directory`: Specifies where capture files should be stored.\n- `filename`: Specifies the exact filename for the capture file. If not specified, a filename will be automatically generated. The automatically generated filename is named `context_id.pcapng` where `context_id` is the value of authentication context ID that can be logged, for example, in the authentication log.\n\nWhen troubleshooting authentication issues, you can correlate authentication log entries with their corresponding capture files using the Context-Id. This example takes the last entry from a JSON formatted authentication log and uses the jq command to extract the value of Context-Id key.\n\n```bash\n% sudo tail -1 radiator-server-authentication.log | jq -r '.[\"Context-Id\"]'\nabc123def456789a\n% sudo ls -l /var/lib/radiator/captures/abc123def456789a.pcapng\n-rw-r----- 1 radiator radiator 41256 Jun  5 09:23 /var/lib/radiator/captures/abc123def456789a.pcapng\n```","insertText":"filename \"${1:radiator-server.pcap}\";"},{"contextPath":[[]],"id":"captures","type":"block","title":"Captures clause","shortDescription":"Configures packet capture for debugging and monitoring network traffic.","content":"# captures\n\nCaptures are used for detailed logging of RADIUS server packets. The capture allows dumping received and sent RADIUS messages to an output specified by the capture configuration. Possible output destinations include the console (stdout), memory, or a file (PcapNG format).\n\nExample configuration of a captures clause with various capture types:\n\n```\ncaptures {\n    capture \"CAPTURE_TO_CONSOLE\" {\n        console;\n    }\n\n    capture \"CAPTURE_TO_MEMORY\" {\n        memory;\n    }\n\n    capture \"CAPTURE_TO_CONSOLE_AND_DIRECTORY\" {\n        console;\n        file {\n            directory \"/var/lib/radiator/captures\";\n        }\n    }\n\n    capture \"CAPTURE_TO_CONSOLE_AND_FILE\" {\n        console;\n        file {\n            directory \"/var/lib/radiator/captures\";\n            filename \"radiator-server.pcap\";\n        }\n    }\n\n    capture \"CAPTURE_TO_DIRECTORY\" {\n        file {\n            directory \"/var/lib/radiator/captures\";\n        }\n    }\n\n    capture \"CAPTURE_TO_FILE\" {\n        file {\n            directory \"/var/lib/radiator/captures\";\n            filename \"radiator-server.pcap\";\n        }\n    }\n}\n```\n\nA capture can be enabled, for example, within:\n\n```\nservers {\n    radius {\n        capture \"EXAMPLE_CAPTURE\";\n\n        # Rest of the radius configuration\n    }\n}\n```\n\n## Capture destinations\n\nThere are three capture output locations:\n\n- console\n- memory\n- file","insertText":"captures {\n\t$0\n}"},{"contextPath":[["captures"]],"id":"capture","type":"block","title":"Capture configuration","shortDescription":"Configures a single capture instance.","content":"# captures\n\nCaptures are used for detailed logging of RADIUS server packets. The capture allows dumping received and sent RADIUS messages to an output specified by the capture configuration. Possible output destinations include the console (stdout), memory, or a file (PcapNG format).\n\nExample configuration of a captures clause with various capture types:\n\n```\ncaptures {\n    capture \"CAPTURE_TO_CONSOLE\" {\n        console;\n    }\n\n    capture \"CAPTURE_TO_MEMORY\" {\n        memory;\n    }\n\n    capture \"CAPTURE_TO_CONSOLE_AND_DIRECTORY\" {\n        console;\n        file {\n            directory \"/var/lib/radiator/captures\";\n        }\n    }\n\n    capture \"CAPTURE_TO_CONSOLE_AND_FILE\" {\n        console;\n        file {\n            directory \"/var/lib/radiator/captures\";\n            filename \"radiator-server.pcap\";\n        }\n    }\n\n    capture \"CAPTURE_TO_DIRECTORY\" {\n        file {\n            directory \"/var/lib/radiator/captures\";\n        }\n    }\n\n    capture \"CAPTURE_TO_FILE\" {\n        file {\n            directory \"/var/lib/radiator/captures\";\n            filename \"radiator-server.pcap\";\n        }\n    }\n}\n```\n\nA capture can be enabled, for example, within:\n\n```\nservers {\n    radius {\n        capture \"EXAMPLE_CAPTURE\";\n\n        # Rest of the radius configuration\n    }\n}\n```\n\n## Capture destinations\n\nThere are three capture output locations:\n\n- console\n- memory\n- file","insertText":"capture \"${1:EXAMPLE_CAPTURE}\" {\n\t$0\n}"},{"contextPath":[["captures","capture"]],"id":"memory","type":"block","title":"Memory capture","shortDescription":"Configures packet capture to memory","content":"# memory\n\nStores the captured RADIUS messages in memory. Packets stored in memory are available with REST API.\n\nExample configuration of a memory capture with default (16384) size:\n\n```\ncaptures {\n    capture \"CAPTURE_TO_MEMORY\" {\n        memory;\n    }\n}\n```","insertText":"memory {\n\tsize ${1:16384};\n}"},{"contextPath":[["captures","capture","memory"]],"id":"size","type":"variable","title":"Size","shortDescription":"Specifies buffer size in bytes.","content":"# size\n\nThe optional size parameter specifies the maximum number of capture packets to be stored in memory. Default value is 16384.","insertText":"size ${1:16384};"},{"contextPath":[["clients","radius","client","source"]],"id":"ip","type":"variable","title":"ip configuration","shortDescription":"IP address from which the client can connect","content":"# ip\n\nThis defines the source address for incoming RADIUS packets. The ip attribute can be defined as an IPv4 or an IPv6 address and does not need an additional prefix to determine the type.\n\nMultiple ip addresses can be defined inside the source clause.","insertText":"ip ${1:0.0.0.0/0};"},{"contextPath":[[]],"id":"clients","type":"block","title":"Client configurations","shortDescription":"Defines client lists that specify which devices can connect to servers and their authentication settings.","content":"# clients\n\nDefines client lists that specify which devices can connect to servers and their authentication settings.","insertText":"clients {\n\t$0\n}"},{"contextPath":[["clients","radius","client","source"]],"id":"protocol","type":"statement","title":"source protocol configuration","shortDescription":"Protocol the client will use to send RADIUS receive","content":"# protocol\n\nThis optional attribute specifies the type of transport layer protocol that the client will use to receive RADIUS requests. The possible values are udp, tcp, and tls.","insertText":"protocol ${1|udp,tcp,tls|};"},{"contextPath":[["clients"]],"id":"radius","type":"block","title":"RADIUS Client configurations","shortDescription":"Define groups of RADIUS clients with a shared configuration.","content":"# radius\n\nA Client clause specifies a RADIUS client that the server will listen to. The client clause must be defined with a string that represents its name. Requests received from any client not named in a Client clause in the configuration file will be silently ignored. The DEFAULT client (if defined) will handle requests from clients that are not defined elsewhere.\n\nYou must have a Client clause for every RADIUS client which your server is expected to serve, or else a DEFAULT Client.\n\nExample configuration of a radius clients list clause:\n\n```\nradius \"CLIENTS_RADIUS_ALL\" {\n    client \"localhost\" {\n        source {\n            ip 127.0.0.1;\n        }\n        secret \"mysecret\";\n    }\n}\n```","insertText":"radius \"${1:LIST_NAME}\" {\n\tclient \"${2:CLIENT_NAME}\" {\n\t\tsource {\n\t\t\tip ${3:192.168.1.0/24};\n\t\t}\n\t\tsecret \"${4:SHARED_SECRET}\";\n\t\t$0\n\t}\n}"},{"contextPath":[["clients","radius","client"]],"id":"require_message_authenticator","type":"statement","title":"Message authenticator requirement","shortDescription":"Whether to require message authenticator attribute in requests","content":"# require_message_authenticator\n\nThis is an optional attribute that indicates whether the RADIUS client should require a message authenticator. The attribute is defined as a boolean. If this attribute is not explicitly defined in the configuration, it will default to 'false'.","insertText":"require_message_authenticator ${1|true,false|};"},{"contextPath":[["clients","radius","client"]],"id":"secret","type":"variable","title":"Shared secret configuration","shortDescription":"Shared secret","content":"# secret\n\nThis defines the shared secret that is used to encrypt and decrypt User-Password and some other less frequently used attributes. Shared secret is also used for RADIUS message integrity checking with the exception of Access-Request messages. You must define a shared secret for each Client, and it must match the secret configured into the client RADIUS software. There is no default. The secret can be any number of ASCII characters. Any ASCII character except newline is permitted, but it might be easier if you restrict yourself to the printable characters. For a reasonable level of security, the secret should be at least 16 characters, and a mixture of upper and lower case, digits and punctuation. You should not use just a single recognizable word. The secret is defined as a string.","insertText":"secret \"${1:SHARED_SECRET}\";"},{"contextPath":[["clients","radius","client"]],"id":"source","type":"block","title":"Source configuration","shortDescription":"Source IP addresses from which the client can connect","content":"# source\n\nSource IP addresses from which this client can connect. Can specify individual IPs or CIDR ranges. Multiple IP blocks allowed.","insertText":"source {\n\tip ${1:192.168.1.0/24};\n\t$0\n}"},{"contextPath":[["clients","radius","client"]],"id":"timeout","type":"variable","title":"Timeout in seconds for client responses","shortDescription":"Timeout in seconds for client response processing","content":"# timeout\n\nThis optional parameter specifies the amount of time that the client will wait for a response from the RADIUS server before considering the request to have timed out.\n\n## Duration Units\n\nThis parameter supports [duration units](/docs/articles/duration-units.md) for improved readability:\n\n```radiator-config\nclients {\n    radius {\n        client \"192.168.1.0/24\" {\n            secret \"ClientSecret\";\n            timeout 30s;  # 30 seconds\n        }\n    }\n}\n```\n\nWhen no unit suffix is provided, the value is interpreted as seconds.","insertText":"timeout ${1:30s};"},{"contextPath":[[]],"id":"dictionary","type":"block","title":"RADIUS dictionary configuration","shortDescription":"Defines custom RADIUS dictionaries that extend the standard attribute definitions with vendor-specific or custom attributes.","content":"# dictionary\n\nThe dictionary file defines easy-to-read names for the attributes and values used in RADIUS messages. It defines how RADIUS attribute numbers map to readable attribute names, and how RADIUS value numbers map to readable value names. The dictionary also defines the type of data that each attribute can hold.\n\nThe dictionary file is an ASCII text file. Each definition occupies one line. A hash mark # marks the beginning of a comment. Comment and blank lines are ignored.\n\nExample configuration of a dictionary clause:\n\n```\ndictionary {\n    radius {\n        filename \"path/to/dictionary\";\n    }\n}\n```\n\n## radius\n\nThis clause defines the RADIUS dictionary file.\n\n### filename\n\nThe name of the dictionary file. The filename attribute can also include the specified directory, e.g., /opt/radiator/server/dictionary. Filename is defined as a string.","insertText":"dictionary {\n\tradius {\n\t\tfilename \"${1:/path/to/dictionary}\";\n\t}\n}"},{"contextPath":[[]],"id":"license","type":"block","title":"License clause","shortDescription":"Used to read the license configuration parameters.","content":"# license\n\nThe license clause is used to read the license configuration parameters. There is no default.\n\nLicense configuration clause:\n\n```\nlicense {\n    # use a license directory to look for licenses\n    directory \"/var/lib/radiator/licenses\";\n}\n```","insertText":"license {\n\tdirectory \"${1:/var/lib/radiator/licenses}\";\n}"},{"contextPath":[["logging"]],"id":"aaa","type":"block","title":"AAA logging clause","shortDescription":"Configures AAA loggers","content":"# aaa\n\nThis clause is used for configuring one or multiple AAA loggers. The AAA loggers are responsible for recording and monitoring authentication, authorization, and accounting activities within the network.\n\nAAA loggers are defined with separate logger clauses inside the AAA block. The logger clause defines a named AAA logger that can be configured to log messages using output methods such as file, memory, and console. Each logger is configured with a name which is defined as a string. A syslog clause can also be defined inside the logger. For more information, see Syslog documentation.","insertText":"aaa {\n\t$0\n}"},{"contextPath":[["logging"]],"id":"application","type":"block","title":"Application logging clause","shortDescription":"Configures application loggers","content":"# application\n\nThis defines the application logger. The application logger is used to record the events in the applications lifecycle.\n\nExample configuration of application logging:\n\n```\napplication {\n    # File logger\n    file {...}\n\n    # In-memory logger\n    memory {...}\n\n    # Console logger\n    console {...}\n\n    # Local syslog logger\n    syslog {...}\n}\n```","insertText":"application {\n\tconsole {\n\t\tloglevel ${1|error,warning,info,debug,trace|};\n\t}\n\t$0\n}"},{"contextPath":[["logging","aaa","logger"],["logging","application"]],"id":"console","type":"block","title":"Console logger configuration","shortDescription":"Configures console-based logging to write log messages to stdout/stderr.","content":"# console\n\nThis is used to configure the console logger which outputs log messages into console.\n\nExample configuration of console logger:\n\n```\nconsole {\n    loglevel warning;\n}\n```\n\nNote that by default, the loglevel inside the console clause is set to info. Therefore, the console logger can also be configured without explicitly specifying a loglevel:\n\n```\nconsole;\n```","insertText":"console {\n\tloglevel ${1|error,warning,info,debug,trace|};\n}"},{"contextPath":[["logging","aaa","logger","syslog"],["logging","application","syslog"]],"id":"facility","type":"statement","title":"Facility","shortDescription":"Configures facility","content":"# facility\n\nThis specifies the name of the system that is logging the syslog message. The facility attribute is defined as a string. The way that a message is handled may differ depending on the facility. Each of these facilities help in organizing and routing syslog messages based on their source.\n\nFacility keywords in syslog are defined as strings. Each facility has a corresponding numerical code. The possible values with their corresponding facility codes are:\n\n- `kern` (0): Kernel messages\n- `user` (1): User-level messages\n- `mail` (2): Mail system\n- `daemon` (3): System daemons\n- `auth` (4): Security/authentication messages\n- `syslog` (5): Messages generated internally by syslog\n- `lpr` (6): Line printer subsystem\n- `news` (7): Network news subsystem\n- `uucp` (8): UUCP subsystem\n- `cron` (9): Cron subsystem\n- `authpriv` (10): Security/authentication messages\n- `ftp` (11): FTP daemon\n- `ntp` (12): NTP subsystem\n- `security` (13): Log audit\n- `console` (14): Log alert\n- `solaris-cron` (15): Scheduling daemon\n- `local0` (16): Locally used facility 0\n- `local1` (17): Locally used facility 1\n- `local2` (18): Locally used facility 2\n- `local3` (19): Locally used facility 3\n- `local4` (20): Locally used facility 4\n- `local5` (21): Locally used facility 5\n- `local6` (22): Locally used facility 6\n- `local7` (23): Locally used facility 7\n\nNote that the mapping between facility codes and keywords is not uniform across different operating systems and syslog implementations. For additional information, refer to your operating system documentation.","insertText":"facility \"${1|kern,user,mail,daemon,auth,syslog,lpr,news,uucp,cron,authpriv,ftp,ntp,security,console,solaris-cron,local0,local1,local2,local3,local4,local5,local6,local7|}\";"},{"contextPath":[["logging","aaa","logger"],["logging","application"]],"id":"file","type":"block","title":"File logger configuration","shortDescription":"Configures file-based logging to write log messages to a file on disk.","content":"# file\n\nThis is used to configure the file logger which stores log messages in a file you specify. The filename should be the preferred log file.\n\nExample configuration of a file logging clause:\n\n```\nfile {\n    filename \"/var/log/radiator/radiator-server.log\";\n    loglevel info;\n}\n```","insertText":"file {\n\tloglevel ${1|error,warning,info,debug,trace|};\n\tfilename \"${2:/var/log/radiator/radiator.log}\";\n}"},{"contextPath":[["logging","aaa"]],"id":"logger","type":"block","title":"Single logger clause","shortDescription":"Configure single logger","content":"# logger\n\nThis clause is used to configure AAA loggers.\n\nExample configuration of a logger:\n\n```\naaa {\n  logger \"EXAMPLE_LOGGER\" {\n    # File logger\n    file {...}\n\n    # In-memory logger\n    memory {...}\n\n    # Local syslog logger\n    syslog {...}\n  }\n}\n```","insertText":"logger \"${1:EXAMPLE_LOGGER}\" {\n\t$0\n}"},{"contextPath":[["logging","aaa","logger","console"],["logging","application","console"],["logging","aaa","logger","memory"],["logging","application","memory"],["logging","aaa","logger","file"],["logging","application","file"],["logging","aaa","logger","syslog"],["logging","application","syslog"]],"id":"loglevel","type":"statement","title":"Loglevel","shortDescription":"Priority level","content":"# loglevel\n\nThis specifies the priority level that depends on the severity of the message. The loglevel attribute is used in all logging methods including syslog.\n\nThere are six possible values for the loglevel:\n\n- `off`: Disables logging.\n- `error`: Logs only error messages, which indicate serious problems.\n- `warning`: Logs warning and error messages, which indicate potential issues that may need attention.\n- `info`: Logs informational, warning, and error messages, providing a general overview of the system's status.\n- `debug`: Logs detailed debugging information, including informational, warning, and error messages.\n- `trace`: Logs very detailed tracing information, including all debug, informational, warning, and error messages, for in-depth troubleshooting.","insertText":"loglevel ${1|error,warning,info,debug,trace|};"},{"contextPath":[[]],"id":"logging","type":"block","title":"Logging clause","shortDescription":"Logging configuration","content":"# logging\n\nThe logging configuration includes two clauses which are application and aaa. Here is an example configuration of the logging clause:\n\n```\nlogging {\n    # Application logging\n    application {...}\n\n    # AAA logger(s)\n    aaa {...}\n}\n```","insertText":"logging {\n\tapplication {\n\t\t$0\n\t}\n\taaa {\n\t\t\n\t}\n}"},{"contextPath":[["logging","aaa","logger"],["logging","application"]],"id":"memory","type":"block","title":"Memory logger configuration","shortDescription":"Configures memory-based logging to store log messages in RAM for fast access.","content":"# memory\n\nThis is used to configure the memory logger which temporarily stores log messages in memory.\n\nExample configuration of a memory logger clause:\n\n```\nmemory {\n    loglevel warning;\n    size 32768;\n}\n```\n\nNote that by default, the loglevel inside the memory clause is set to info, and the size is set to 16384. Therefore, the memory logger can also be configured without explicitly specifying a loglevel and size:\n\n```\nmemory;\n```","insertText":"memory {\n\tloglevel ${1|error,warning,info,debug,trace|};\n\tsize ${2:16384};\n}"},{"contextPath":[["logging","aaa","logger","memory"],["logging","application","memory"]],"id":"size","type":"variable","title":"Size of memory","shortDescription":"Specifies max number of entries in memory","content":"# size\n\nThis specifies the maximum number of log entries to be stored in memory. Default value is 16384.","insertText":"size 16384;"},{"contextPath":[["logging","aaa","logger"],["logging","application"]],"id":"syslog","type":"block","title":"Syslog logger configuration","shortDescription":"Configures syslog-based logging to send log messages to the system syslog daemon.","content":"# syslog\n\nThis optional clause creates a syslog logger, which logs all messages with a specified priority level or higher to the syslog system.\n\nMessages are logged to syslog with severity levels that depend on the severity of the message. There are 8 defined priority levels in syslog, and they are logged to the equivalent syslog priority. The priority levels with their corresponding values and descriptions are:\n\n- Emergency (0): System is unusable\n- Alert (1): Immediate action needed\n- Critical (2): Critical conditions\n- Error (3): Error conditions\n- Warning (4): Warning conditions\n- Notice (5): Normal but significant conditions\n- Informational (6): Informational messages\n- Debug (7): Debug-level messages\n\nExample configuration of a syslog logger:\n\n```\nsyslog {\n    loglevel info;\n    facility daemon;\n\n    # optional syslog unix domain socket path\n    #filename /var/run/syslog;\n}\n```","insertText":"syslog {\n\tloglevel ${1|error,warning,info,debug,trace|};\n\tfacility \"${2|kern,user,mail,daemon,auth,syslog,lpr,news,uucp,cron,authpriv,ftp,ntp,security,console,solaris-cron,local0,local1,local2,local3,local4,local5,local6,local7|}\";\n}"},{"contextPath":[["servers","radius","listen"]],"id":"buffer","type":"variable","title":"RADIUS server listen buffer","shortDescription":"Used to receive and send buffer size in bytes.","content":"# buffer\n\nThis optional attribute is used to receive and send buffer size in bytes. Buffer is defined as an integer. If the buffer field is left unspecified, it will default to the operating system default value.","insertText":"buffer $0;"},{"contextPath":[["servers","radius"]],"id":"clients","type":"variable","title":"RADIUS client list reference","shortDescription":"References a client list definition that specifies which clients can connect to this server.","content":"# clients\n\nList of clients the RADIUS server will listen to. The client list name is defined as a string. For more information, see Clients documentation.","insertText":"clients \"${1:CLIENTS_LIST}\";"},{"contextPath":[["servers","radius","listen"]],"id":"ip","type":"statement","title":"RADIUS server listen ip","shortDescription":"Configures the ip address(es) the server will listen on.","content":"# ip\n\nThis specifies the ip address(es) on which the server will listen for incoming connections. The ip attribute can be defined as an IPv4 or an IPv6 address and does not need an additional prefix to determine the type.\n\nRecommended listen configuration:\n\n```\nlisten {\n    # Bind to all IPv4 addresses\n    ip 0.0.0.0;\n\n    # Bind to all IPv6 addresses\n    ip 0::0;\n}\n```\n\nWhen the IP attribute is defined as `0.0.0.0` (for IPv4) or `0::0` (for IPv6), the server will listen on all available network interfaces for that particular protocol. If the server is configured with either of those, no other IP addresses with the same protocol can be declared.\n\nMultiple specific IP addresses can also be configured:\n\n```\nlisten {\n    ...\n\n    ip 127.0.0.1;\n    ip 192.0.2.42;\n    ip 2001:db8::42;\n    ip 2001:db8::43;\n}\n```","insertText":"ip ${1|0.0.0.0,0::0|};"},{"contextPath":[[]],"id":"servers","type":"block","title":"servers clause","shortDescription":"Configures servers","content":"# servers\n\nOne protocol and port per server supported. Each server clause must be configured with a string that represents its name.\n\nExample configuration of a servers clause with two simple RADIUS server configurations:\n\n```\nservers {\n    radius \"server-radius-auth-udp-1812\" {\n        capture \"console-capture\";\n        listen {...}\n\n        # Allow connections/requests from clients in a client list \"clients-radius-all\"\n        clients \"clients-radius-all\";\n\n        # (Optional) Handle all requests by AAA policy named \"auth\"\n        #policy \"auth\";\n    }\n\n    radius \"server-radius-acct-udp-1813\" {\n        listen {...}\n\n        # Allow connections/requests from clients in a client list \"clients-radius-all\"\n        clients \"clients-radius-all\";\n    }\n}\n```","insertText":"servers {\n\t$0\n}"},{"contextPath":[["servers","radius"]],"id":"policy","type":"variable","title":"RADIUS policy","shortDescription":"References a policy that defines how to handle authentication and accounting requests.","content":"# policy\n\nThis optional attribute is used to handle all requests by AAA policy that is named as the same as the policy name given. The policy attribute works as follows:\n\n1. Check if there exists policy that matches the name, if yes, use it regardless what might be the conditions for the policy.\n2. If there is no policy with exact name match, use the first policy that has matching conditions.\n3. Use DEFAULT policy if such exists. We always recommend having a DEFAULT policy where authentications can be rejected and accounting accepted.\n4. If no matching policy is found, the request is not processed.\n\nThe parameter type for the policy is string. For more information, see Policy documentation.","insertText":"policy \"${1:POLICY_NAME}\";"},{"contextPath":[["servers","radius","listen"]],"id":"port","type":"statement","title":"RADIUS server listen port","shortDescription":"Configures the port for the RADIUS server.","content":"# port\n\nSpecifies which port(s) Radiator will listen on for RADIUS requests. The port parameter is defined as a NonZeroU16 which is a non-zero 16-bit unsigned integer. There can only be one port specified per a listen clause.","insertText":"port ${1|1812,1813|};"},{"contextPath":[["servers","radius","listen"]],"id":"protocol","type":"statement","title":"RADIUS server listen protocol","shortDescription":"Configures the protocol for the RADIUS server.","content":"# protocol\n\nThe protocol attribute specifies the type of protocol used by the RADIUS server to receive and handle requests. The possible values are udp, tcp, and tls.","insertText":"protocol ${1|udp,tcp,tls|};"},{"contextPath":[["servers","radius"]],"id":"listen","type":"block","title":"RADIUS server listen configuration","shortDescription":"Configures the network interface, protocol, and port for the RADIUS server.","content":"# listen\n\nThe listen attribute is used to configure the network interfaces and ports on which the RADIUS server will accept requests. This is used to define specific IP addresses and ports for handling RADIUS traffic.\n\nExample configuration of a listen clause:\n\n```\nlisten {\n    # Transport protocol\n    protocol udp;\n\n    # Transport protocol port to listen to\n    port 1813;\n\n    # IPv4 address to listen to\n    ip 127.0.0.1;\n}\n```","insertText":"listen {\n\tprotocol ${1|udp,tcp,tls|};\n\tport ${2|1812,1813|};\n\tip ${3|0.0.0.0,0::0|};\n\t$0\n}"},{"contextPath":[["servers"]],"id":"radius","type":"block","title":"RADIUS server configuration","shortDescription":"Remote Authentication Dial-In User Service server for AAA operations.","content":"# radius\n\nBeginning of a RADIUS server clause. The clause has a name which is defined as a string. Multiple RADIUS clauses can be configured inside the servers clause.","insertText":"radius \"${1:SERVER_NAME}\" {\n\tlisten {\n\t\tprotocol ${2|udp,tcp,tls|};\n\t\tport ${3|1812,1813|};\n\t\tip ${4|0.0.0.0,0::0|};\n\t}\n\t$0\n}"}]}